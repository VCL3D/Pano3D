<!Doctype html>
<html lang="en">
    <head>
        <title>Pano3d: A Holistic Benchmark and a Solid Baseline for 360<sup>o</sup> Depth Estimation</title>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="author" content="Georgios Albanis">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="stylesheet" type="text/css" href="style_project_page.css?cache=7733391418498779679">
        <link href="https://fonts.googleapis.com/css?family=Arvo|Roboto&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css">
        <link rel="stylesheet" href="https://unpkg.com/@glidejs/glide/dist/css/glide.core.min.css">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="https://unpkg.com/@glidejs/glide"></script>
        <style type="text/css">
            .side-text {
                width:60%;
                display:inline-block;
                vertical-align:top;
            }
            .side-image {
                width: 38%;
                display: inline-block;
                vertical-align: top;
            }
            .controls {
                margin-bottom: 10px;
            }
            .left-controls {
                display: inline-block;
                vertical-align: top;
                width: 80%;
            }
            .right-controls {
                display: inline-block;
                vertical-align: top;
                width: 19%;
                text-align: right;
            }
            .render_window {
                display: inline-block;
                vertical-align: middle;
                box-shadow: 1px 0px 5px black;
                margin-right: 10px;
                margin-bottom: 10px;
                width: calc(33% - 10px);
            }
            .progress {
                background: #666;
                position: relative;
                height: 5px;
                margin-bottom: -5px;
                display: none;
            }
            .glide__slide:hover {cursor: grab;}
            .glide__slide:active {cursor: grabbing;}
            .glide__slide img {width: 90%;}
            .glide__bullets {
                text-align: center;
            }
            .glide__bullet--active {
                color: #aaa; 
            }

            @media (max-width: 400px) {
                .render_window {
                    display: block;
                    width: 90%;
                    margin: 10px auto;
                }
            }
            @media (max-width: 700px) {
                .side-image {
                    display: block;
                    width: 80%;
                    margin: 10px auto;
                }
                .side-text {
                    display: block;
                    width: 100%;
                }
            }
        </style>
    </head>
    <body>
        <div class="section">
            <h1 class="project-title">
                Pano3d: A Holistic Benchmark and a Solid Baseline for 360<sup>o</sup> Depth Estimation
            </h1>
            <div class="authors">
                <a href=https://tzole1155.github.io/>
                    Georgios Albanis <sup>1</sup>
                </a>
                <a href=https://zokin.github.io/>
                    Nikolaos Zioulis <sup>1,2</sup>
                </a>
                <a href=https://github.com/pdrak/>
                    Petros Drakoulis <sup>1</sup>
                </a>
                <a href=https://github.com/VasilisGks/>
                        Vasileios Gkitsas <sup>1</sup>
                </a>
                <a href=https://github.com/vladsterz/>
                        Vladimiros Sterzentsenko  <sup>1</sup>
                </a>
                <a href=http://www.gatv.ssr.upm.es//>
                        Federico Alvarez  <sup>2</sup>
                </a>
                <a href=https://www.iti.gr/iti/people/Dimitrios_Zarpalas.html/>
                        Dimitrios Zarpalas <sup>1</sup>
                </a>
                <a href=https://www.iti.gr/iti/people/Petros_Daras.html/>
                        Petros Daras <sup>1</sup>
                    </a>
            </div>

            <div class="affiliations">
                <span><sup>1</sup> Centre for Research and Technology Hellas, Thessaloniki, Greece</span><br>
                <span><sup>2</sup> Universidad Politécnica de Madrid, Madrid, Spain</span> <br/>
            </div>

            <div class="project-conference">
                <a href=https://sites.google.com/view/omnicv2021//>
                    OmniCV 2021
                </a>
            </div>

            <div class="project-icons">
                <a href="">
                    <i class="fa fa-file"></i> <br/>
                    Paper
                </a>
                <a href="https://github.com/VCL3D/Pano3D">
                    <i class="fa fa-github"></i> <br/>
                    Code
                </a>
                <!--<a href="https://">
                    <i class="fa fa-youtube-play"></i> <br/>
                    Video
                </a>-->
                <!--<a href="https://">
                    <i class="fa fa-picture-o"></i> <br/>
                    Poster
                </a>
                <a href="http://">
                    <i class="fa fa-file-powerpoint-o"></i> <br/>
                    Slides
                </a>
                <a href="https://">
                    <i class="fa fa-newspaper-o"></i> <br/>
                    Blog
                </a>-->
            </div>

            <div class="teaser-image">
                <img src="images/teaser.png" style="width:100%;">
                <p class="caption">Preserving depth's piece-wise smoothness should be the primary goal of data-driven depth estimation models.
                    Yet most works only assess direct depth performance neglecting secondary traits like smoothness or boundary preservation.
                    Different architectures (UNet -- left, or Pnas -- right) exhibit different inference characteristics skewed towards boundaries (UNet) or smoothness (Pnas).
                    The Pano3D benchmark descends from a holistic perspective taking into account all performance traits, and additionally focuses on an orthogonal performance direction, generalization to unseen data from different distributions, contexts or domains. </p>
            </div>

            <div class="section-title">Results</div>
            <div class="content">
                In the following interactive visualization, we provide qualitative results for the UNet model.

                <h3>Input Panoramas</h3>
                <div id="input_panoramas">
                    <div class="render_container">
                        <div data-size="400" class="render_window"></div><div data-size="400" class="render_window"></div><div data-size="400" class="render_window"></div>
                    </div>
                </div>

                <h3>Predicted meshes</h3>
                <div id="pred_meshes">
                    <div class="render_container">
                        <div data-size="400" class="render_window"></div><div data-size="400" class="render_window"></div><div data-size="400" class="render_window"></div>
                    </div>
                </div>
            </div>

            <div class="section-title">Acknowledgements</div>
            <div class="content">
                This project has received funding from the European Union’s Horizon 2020 innovation programme <a href="https://atlantis-ar.eu/">ATLANTIS</a> under grant agreement No 951900.
            </div>
        </div>

        <script type="module">
            import * as THREE from "https://unpkg.com/three/build/three.module.js";
            import { OrbitControls } from "https://unpkg.com/three/examples/jsm/controls/OrbitControls.js";
            import {OBJLoader} from "https://unpkg.com/three/examples/jsm/loaders/OBJLoader.js";
            // import { PLYLoader } from './js/loaders/PLYLoader.js';
            import { MTLLoader } from "https://unpkg.com/three/examples/jsm/loaders/MTLLoader"

            // Render the predictions
            function random_choice(arr, n) {
                var index_set = {};
                var choice = [];
                while (choice.length < n) {
                    var idx = Math.floor(Math.random() * arr.length);
                    if (index_set[idx] !== undefined) {
                        continue;
                    }
                    index_set[idx] = 0;
                    choice.push(idx);
                }

                return choice.map(x => arr[x]);
            }

            function progress_bar() {
                var el = document.createElement("div");
                el.classList.add("progress");

                return {
                    domElement: el,
                    update: function (percent) {
                        percent = Math.min(1, Math.max(0, percent));
                        el.style.display = "block";
                        el.style.width = Math.round(percent * 100) + "%";
                    },
                    hide: function () {
                        el.style.display = "none";
                    }
                };
            }

            function reset_checkboxes(checkboxes) {
                Array.prototype.forEach.call(checkboxes, function (c) {
                    c.checked = false;
                });
                checkboxes[0].checked = true;
            }

            function show_ply(el,prefix,N){
                const scene = new THREE.Scene();
                const renderer = new THREE.WebGLRenderer();
                const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                const controls = new OrbitControls(camera, renderer.domElement);

                camera.position.set(0.5, 0.5, 0.5);
                controls.target.set(0, 0, 0);
                controls.autoRotate = true;
                controls.autoRotateSpeed = 4;
                scene.background = new THREE.Color("white");
                var size = el.dataset.size;
                renderer.setSize(size, size);
                var progress = progress_bar();
                el.appendChild(progress.domElement);
                el.appendChild(renderer.domElement);

                const amb_light = new THREE.AmbientLight(0x606060); // soft white light
                scene.add(amb_light);
                const hem_light = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
                scene.add(hem_light);

                var previous_canvas_size = size;
                function animate() {
                    requestAnimationFrame(animate);
                    if (el.offsetWidth != previous_canvas_size) {
                        previous_canvas_size = el.offsetWidth;
                        renderer.domElement.style.width = previous_canvas_size + "px";
                        renderer.domElement.style.height = previous_canvas_size + "px";
                    }

                    controls.update();
                    renderer.render(scene, camera);
                }

                const loader = new OBJLoader();
                var meshes = [];
                var progresses = [];
                var loaded = 0;
                function load_ply(ply_idx) {
                    progresses[ply_idx] = 0;
                    loader.load( 'ply/pred_0_mesh.obj', function ( geometry ) {
                        //var geometry = object.children[0].geometry;
                        //geometry.computeVertexNormals();
                        var material = new THREE.MeshStandardMaterial( { color: 0xffffff, specular: 0x111111, shininess: 200 } );
                        material.transparent = true;
                        var mesh = new THREE.Mesh( geometry, material );
                        //mesh.position.y = - 0.2;
                        //mesh.position.z = 0.3;
                        //mesh.rotation.x = - Math.PI / 2;
                        //mesh.scale.multiplyScalar( 0.001 );
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        meshes[ply_idx] = mesh;
                        scene.add( mesh );
                        loaded++;
                        if (loaded == N) {
                            progress.hide();
                        }
                    });
                }
                for (var i=0; i<N; i++) {
                    load_ply(i);
                }
                animate();
                return {
                    meshes: meshes,
                    show: function (indices) {
                        for (var i=0; i<N; i++) {
                            meshes[i].material.opacity = 0.5;
                            //meshes[i].visible = false;
                        }
                        for (var i=0; i<indices.length; i++) {
                            meshes[indices[i]].material.opacity = 1;
                            //meshes[indices[i]].visible = true;
                        }
                    },
                    show_all: function () {
                        for (var i=0; i<N; i++) {
                            meshes[i].material.opacity = 1;
                            //meshes[i].visible = true;
                        }
                    },
                    set_size: function(width, height) {
                        renderer.setSize(width, height);
                    }
                };

            }

            function show_mesh(el,prefix,N){

                const scene = new THREE.Scene();
                const renderer = new THREE.WebGLRenderer();
                const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                const controls = new OrbitControls(camera, renderer.domElement);

                camera.position.set(0.5, 0.5, 0.5);
                controls.target.set(0, 0, 0);
                controls.autoRotate = true;
                controls.autoRotateSpeed = 4;
                scene.background = new THREE.Color("white");
                var size = el.dataset.size;
                renderer.setSize(size, size);
                var progress = progress_bar();
                el.appendChild(progress.domElement);
                el.appendChild(renderer.domElement);

                const amb_light = new THREE.AmbientLight(0x606060); // soft white light
                scene.add(amb_light);
                const hem_light = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
                scene.add(hem_light);

                var previous_canvas_size = size;
                function animate() {
                    requestAnimationFrame(animate);
                    if (el.offsetWidth != previous_canvas_size) {
                        previous_canvas_size = el.offsetWidth;
                        renderer.domElement.style.width = previous_canvas_size + "px";
                        renderer.domElement.style.height = previous_canvas_size + "px";
                    }

                    controls.update();
                    renderer.render(scene, camera);
                }

                const mtlLoader = new MTLLoader();
                var meshes = [];
                var progresses = [];
                var loaded = 0;
                function load_mesh(mesh_idx) {
                    progresses[mesh_idx] = 0;
                    mtlLoader.load(prefix.replace("obj","mtl"),
                    // mtlLoader.load('ply/pred_0_mesh.mtl',
                    (materials) => {
                            materials.preload();

                            const objLoader = new OBJLoader();
                            objLoader.setMaterials(materials);
                            objLoader.load(prefix,
                            (object) => {
                                scene.add(object);
                                meshes[mesh_idx] = object;
                            },)
                    });
                }
                for (var i=0; i<N; i++) {
                    load_mesh(i);
                }
                animate();
                return {
                    meshes: meshes,
                    show: function (indices) {
                        for (var i=0; i<N; i++) {
                            meshes[i].material.opacity = 0.5;
                            //meshes[i].visible = false;
                        }
                        for (var i=0; i<indices.length; i++) {
                            meshes[indices[i]].material.opacity = 1;
                            //meshes[indices[i]].visible = true;
                        }
                    },
                    show_all: function () {
                        for (var i=0; i<N; i++) {
                            meshes[i].material.opacity = 1;
                            //meshes[i].visible = true;
                        }
                    },
                    set_size: function(width, height) {
                        renderer.setSize(width, height);
                    }
                };
        }

            function show_object(el, prefix, N) {
                const scene = new THREE.Scene();
                const renderer = new THREE.WebGLRenderer();
                const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                const controls = new OrbitControls(camera, renderer.domElement);

                camera.position.set(0.5, 0.5, 0.5);
                controls.target.set(0, 0, 0);
                controls.autoRotate = true;
                controls.autoRotateSpeed = 4;
                scene.background = new THREE.Color("white");
                var size = el.dataset.size;
                renderer.setSize(size, size);
                var progress = progress_bar();
                el.appendChild(progress.domElement);
                el.appendChild(renderer.domElement);

                const amb_light = new THREE.AmbientLight(0x606060); // soft white light
                scene.add(amb_light);
                const hem_light = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
                scene.add(hem_light);

                const colors = [
                    0x1f77b4,
                    0xaec7e8,
                    0xff7f0e,
                    0xffbb78,
                    0x2ca02c,
                    0x98df8a,
                    0xd62728,
                    0xff9896,
                    0x9467bd,
                    0xc5b0d5,
                    0x8c564b,
                    0xc49c94,
                    0xe377c2,
                    0xf7b6d2,
                    0x7f7f7f,
                    0xc7c7c7,
                    0xbcbd22,
                    0xdbdb8d,
                    0x17becf,
                    0x9edae5
                ];
                var previous_canvas_size = size;
                function animate() {
                    requestAnimationFrame(animate);
                    if (el.offsetWidth != previous_canvas_size) {
                        previous_canvas_size = el.offsetWidth;
                        renderer.domElement.style.width = previous_canvas_size + "px";
                        renderer.domElement.style.height = previous_canvas_size + "px";
                    }

                    controls.update();
                    renderer.render(scene, camera);
                }

                const loader = new OBJLoader();
                var meshes = [];
                var progresses = [];
                var loaded = 0;
                function load_part(part_idx) {
                    progresses[part_idx] = 0;
                    loader.load(
                        prefix,
                        function (object) {
                            //var g = geometry;
                            //var m = new THREE.MeshLambertMaterial({color: 0x111111});
                            //m.transparent = true;
                            //var mesh = new THREE.Mesh(g, m);
                            meshes[part_idx] = object;
                            scene.add(object);

                            loaded++;
                            if (loaded == N) {
                                progress.hide();
                            }
                        },
                    );
                }
                for (var i=0; i<N; i++) {
                    load_part(i);
                }
                animate();

                return {
                    meshes: meshes,
                    show: function (indices) {
                        for (var i=0; i<N; i++) {
                            meshes[i].material.opacity = 0.5;
                            //meshes[i].visible = false;
                        }
                        for (var i=0; i<indices.length; i++) {
                            meshes[indices[i]].material.opacity = 1;
                            //meshes[indices[i]].visible = true;
                        }
                    },
                    show_all: function () {
                        for (var i=0; i<N; i++) {
                            meshes[i].material.opacity = 1;
                            //meshes[i].visible = true;
                        }
                    },
                    set_size: function(width, height) {
                        renderer.setSize(width, height);
                    }
                };
            }


            function show_pano(el,prefix,N){
				const scene = new THREE.Scene();
                const renderer = new THREE.WebGLRenderer();
                const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
				const geometry = new THREE.SphereGeometry( 500, 60, 40 );
                const controls = new OrbitControls(camera, renderer.domElement);
				camera.position.set(0.5, 0.5, 0.5);
                controls.target.set(0, 0, 0);
                controls.autoRotate = true;
                controls.autoRotateSpeed = 4;
                scene.background = new THREE.Color("white");
				var size = el.dataset.size;
                renderer.setSize(size, size);
                var progress = progress_bar();
                el.appendChild(progress.domElement);
                el.appendChild(renderer.domElement);
				// invert the geometry on the x-axis so that all of the faces point inward
				geometry.scale( - 1, 1, 1 );

				var previous_canvas_size = size;
                function animate() {
                    requestAnimationFrame(animate);
                    if (el.offsetWidth != previous_canvas_size) {
                        previous_canvas_size = el.offsetWidth;
                        renderer.domElement.style.width = previous_canvas_size + "px";
                        renderer.domElement.style.height = previous_canvas_size + "px";
                    }

                    controls.update();
                    renderer.render(scene, camera);
                }

				var meshes = [];
                var progresses = [];
                var loaded = 0;

				function load_pano(pano_idx){
					progresses[pano_idx] = 0;
                    //console.log("dpepdle" + prefix);
					//var texture = new THREE.TextureLoader().load( 'panoramas/color_0.png' );
                    var texture = new THREE.TextureLoader().load(prefix);
					var material = new THREE.MeshBasicMaterial( { map: texture } );

					var mesh = new THREE.Mesh( geometry, material );
					meshes[pano_idx] = mesh;
					scene.add( mesh );
					loaded++;
                    if (loaded == N) {
                        progress.hide();
                    }
				}
				for (var i=0; i<N; i++) {
                    load_pano(i);
                }
                animate();

				return {
                    meshes: meshes,
                    show: function (indices) {
                        for (var i=0; i<N; i++) {
                            meshes[i].material.opacity = 0.5;
                            //meshes[i].visible = false;
                        }
                        for (var i=0; i<indices.length; i++) {
                            meshes[indices[i]].material.opacity = 1;
                            //meshes[indices[i]].visible = true;
                        }
                    },
                    show_all: function () {
                        for (var i=0; i<N; i++) {
                            meshes[i].material.opacity = 1;
                            //meshes[i].visible = true;
                        }
                    },
                    set_size: function(width, height) {
                        renderer.setSize(width, height);
                    }
                };

			}

            function show_group_panos(elements, objects, N) {
                var controls = [];
                for (var i=0; i<objects.length; i++) {
                    controls.push(show_pano(elements[i], objects[i], N));
                }

                return {
                    controls: controls,
                    show: function (indices) {
                        for (var i=0; i<controls.length; i++) {
                            controls[i].show(indices);
                        }
                    },
                    show_all: function () {
                        for (var i=0; i<controls.length; i++) {
                            controls[i].show_all();
                        }
                    }
                };
            }

            function show_group_meshes(elements, objects, N) {
                var controls = [];
                for (var i=0; i<objects.length; i++) {
                    controls.push(show_mesh(elements[i], objects[i], N));
                }

                return {
                    controls: controls,
                    show: function (indices) {
                        for (var i=0; i<controls.length; i++) {
                            controls[i].show(indices);
                        }
                    },
                    show_all: function () {
                        for (var i=0; i<controls.length; i++) {
                            controls[i].show_all();
                        }
                    }
                };
            }

            function show_group(elements, objects, N) {
                var controls = [];
                for (var i=0; i<objects.length; i++) {
                    controls.push(show_object(elements[i], objects[i], N));
                }

                return {
                    controls: controls,
                    show: function (indices) {
                        for (var i=0; i<controls.length; i++) {
                            controls[i].show(indices);
                        }
                    },
                    show_all: function () {
                        for (var i=0; i<controls.length; i++) {
                            controls[i].show_all();
                        }
                    }
                };
            }

            // panoramas
            var panos = [
                "panoramas/color_0.png",
                "panoramas/color_7.png",
                "panoramas/color_21.png",
            ];

            var panos = show_group_panos(
                document.getElementById("input_panoramas").getElementsByClassName("render_window"),
                [panos[0], panos[1], panos[2]],
                6
            );

            //meshes
            var meshes_paths = [
                "meshes/pred_0_mesh.obj",
                "meshes/pred_7_mesh.obj",
                "meshes/pred_21_mesh.obj",
            ];
            var non_coloured_meshes = show_group(
                document.getElementById("pred_meshes").getElementsByClassName("render_window"),
                [meshes_paths[0], meshes_paths[1], meshes_paths[2]],
                6
            );
        </script>
    </body>
</html>
